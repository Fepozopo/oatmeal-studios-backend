// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: planograms.sql

package database

import (
	"context"
	"database/sql"
)

const assignPlanogramToLocation = `-- name: AssignPlanogramToLocation :one
INSERT INTO planogram_customer_locations (planogram_id, customer_location_id)
VALUES ($1, $2)
ON CONFLICT (planogram_id, customer_location_id) DO NOTHING
RETURNING id, planogram_id, customer_location_id
`

type AssignPlanogramToLocationParams struct {
	PlanogramID        int32 `json:"planogram_id"`
	CustomerLocationID int32 `json:"customer_location_id"`
}

func (q *Queries) AssignPlanogramToLocation(ctx context.Context, arg AssignPlanogramToLocationParams) (PlanogramCustomerLocation, error) {
	row := q.queryRow(ctx, q.assignPlanogramToLocationStmt, assignPlanogramToLocation, arg.PlanogramID, arg.CustomerLocationID)
	var i PlanogramCustomerLocation
	err := row.Scan(&i.ID, &i.PlanogramID, &i.CustomerLocationID)
	return i, err
}

const createPlanogram = `-- name: CreatePlanogram :one
INSERT INTO planograms (name, num_pockets, notes)
VALUES ($1, $2, $3)
RETURNING id, name, num_pockets, notes, created_at, updated_at
`

type CreatePlanogramParams struct {
	Name       string         `json:"name"`
	NumPockets int32          `json:"num_pockets"`
	Notes      sql.NullString `json:"notes"`
}

func (q *Queries) CreatePlanogram(ctx context.Context, arg CreatePlanogramParams) (Planogram, error) {
	row := q.queryRow(ctx, q.createPlanogramStmt, createPlanogram, arg.Name, arg.NumPockets, arg.Notes)
	var i Planogram
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NumPockets,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPlanogramPocket = `-- name: CreatePlanogramPocket :one
INSERT INTO planogram_pockets (planogram_id, pocket_number, category, product_id)
VALUES ($1, $2, $3, $4)
RETURNING id, planogram_id, pocket_number, category, product_id
`

type CreatePlanogramPocketParams struct {
	PlanogramID  int32         `json:"planogram_id"`
	PocketNumber int32         `json:"pocket_number"`
	Category     string        `json:"category"`
	ProductID    sql.NullInt32 `json:"product_id"`
}

func (q *Queries) CreatePlanogramPocket(ctx context.Context, arg CreatePlanogramPocketParams) (PlanogramPocket, error) {
	row := q.queryRow(ctx, q.createPlanogramPocketStmt, createPlanogramPocket,
		arg.PlanogramID,
		arg.PocketNumber,
		arg.Category,
		arg.ProductID,
	)
	var i PlanogramPocket
	err := row.Scan(
		&i.ID,
		&i.PlanogramID,
		&i.PocketNumber,
		&i.Category,
		&i.ProductID,
	)
	return i, err
}

const deletePlanogram = `-- name: DeletePlanogram :exec
DELETE FROM planograms WHERE id = $1
`

func (q *Queries) DeletePlanogram(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.deletePlanogramStmt, deletePlanogram, id)
	return err
}

const deletePlanogramPocket = `-- name: DeletePlanogramPocket :exec
DELETE FROM planogram_pockets WHERE id = $1
`

func (q *Queries) DeletePlanogramPocket(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.deletePlanogramPocketStmt, deletePlanogramPocket, id)
	return err
}

const getPlanogram = `-- name: GetPlanogram :one

SELECT id, name, num_pockets, notes, created_at, updated_at FROM planograms WHERE id = $1
`

// filepath: sql/queries/planograms.sql
func (q *Queries) GetPlanogram(ctx context.Context, id int32) (Planogram, error) {
	row := q.queryRow(ctx, q.getPlanogramStmt, getPlanogram, id)
	var i Planogram
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NumPockets,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlanogramPocket = `-- name: GetPlanogramPocket :one
SELECT id, planogram_id, pocket_number, category, product_id FROM planogram_pockets WHERE id = $1
`

func (q *Queries) GetPlanogramPocket(ctx context.Context, id int32) (PlanogramPocket, error) {
	row := q.queryRow(ctx, q.getPlanogramPocketStmt, getPlanogramPocket, id)
	var i PlanogramPocket
	err := row.Scan(
		&i.ID,
		&i.PlanogramID,
		&i.PocketNumber,
		&i.Category,
		&i.ProductID,
	)
	return i, err
}

const getPlanogramPocketByNumber = `-- name: GetPlanogramPocketByNumber :one
SELECT id, planogram_id, pocket_number, category, product_id FROM planogram_pockets WHERE planogram_id = $1 AND pocket_number = $2
`

type GetPlanogramPocketByNumberParams struct {
	PlanogramID  int32 `json:"planogram_id"`
	PocketNumber int32 `json:"pocket_number"`
}

func (q *Queries) GetPlanogramPocketByNumber(ctx context.Context, arg GetPlanogramPocketByNumberParams) (PlanogramPocket, error) {
	row := q.queryRow(ctx, q.getPlanogramPocketByNumberStmt, getPlanogramPocketByNumber, arg.PlanogramID, arg.PocketNumber)
	var i PlanogramPocket
	err := row.Scan(
		&i.ID,
		&i.PlanogramID,
		&i.PocketNumber,
		&i.Category,
		&i.ProductID,
	)
	return i, err
}

const listLocationsByPlanogram = `-- name: ListLocationsByPlanogram :many
SELECT cl.id, cl.customer_id, cl.address_1, cl.address_2, cl.city, cl.state, cl.zip_code, cl.phone, cl.notes, cl.created_at, cl.updated_at
FROM customer_locations cl
JOIN planogram_customer_locations pcl ON cl.id = pcl.customer_location_id
WHERE pcl.planogram_id = $1
ORDER BY cl.id
`

func (q *Queries) ListLocationsByPlanogram(ctx context.Context, planogramID int32) ([]CustomerLocation, error) {
	rows, err := q.query(ctx, q.listLocationsByPlanogramStmt, listLocationsByPlanogram, planogramID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CustomerLocation
	for rows.Next() {
		var i CustomerLocation
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Address1,
			&i.Address2,
			&i.City,
			&i.State,
			&i.ZipCode,
			&i.Phone,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlanograms = `-- name: ListPlanograms :many
SELECT id, name, num_pockets, notes, created_at, updated_at FROM planograms ORDER BY created_at DESC
`

func (q *Queries) ListPlanograms(ctx context.Context) ([]Planogram, error) {
	rows, err := q.query(ctx, q.listPlanogramsStmt, listPlanograms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Planogram
	for rows.Next() {
		var i Planogram
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.NumPockets,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlanogramsByLocation = `-- name: ListPlanogramsByLocation :many
SELECT p.id, p.name, p.num_pockets, p.notes, p.created_at, p.updated_at
FROM planograms p
JOIN planogram_customer_locations pcl ON p.id = pcl.planogram_id
WHERE pcl.customer_location_id = $1
ORDER BY p.created_at DESC
`

func (q *Queries) ListPlanogramsByLocation(ctx context.Context, customerLocationID int32) ([]Planogram, error) {
	rows, err := q.query(ctx, q.listPlanogramsByLocationStmt, listPlanogramsByLocation, customerLocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Planogram
	for rows.Next() {
		var i Planogram
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.NumPockets,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPocketsForPlanogram = `-- name: ListPocketsForPlanogram :many
SELECT id, planogram_id, pocket_number, category, product_id FROM planogram_pockets WHERE planogram_id = $1 ORDER BY pocket_number
`

func (q *Queries) ListPocketsForPlanogram(ctx context.Context, planogramID int32) ([]PlanogramPocket, error) {
	rows, err := q.query(ctx, q.listPocketsForPlanogramStmt, listPocketsForPlanogram, planogramID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlanogramPocket
	for rows.Next() {
		var i PlanogramPocket
		if err := rows.Scan(
			&i.ID,
			&i.PlanogramID,
			&i.PocketNumber,
			&i.Category,
			&i.ProductID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removePlanogramFromLocation = `-- name: RemovePlanogramFromLocation :exec
DELETE FROM planogram_customer_locations
WHERE planogram_id = $1 AND customer_location_id = $2
`

type RemovePlanogramFromLocationParams struct {
	PlanogramID        int32 `json:"planogram_id"`
	CustomerLocationID int32 `json:"customer_location_id"`
}

func (q *Queries) RemovePlanogramFromLocation(ctx context.Context, arg RemovePlanogramFromLocationParams) error {
	_, err := q.exec(ctx, q.removePlanogramFromLocationStmt, removePlanogramFromLocation, arg.PlanogramID, arg.CustomerLocationID)
	return err
}

const updatePlanogram = `-- name: UpdatePlanogram :one
UPDATE planograms
SET name = $2,
    num_pockets = $3,
    notes = $4,
    updated_at = NOW()
WHERE id = $1
RETURNING id, name, num_pockets, notes, created_at, updated_at
`

type UpdatePlanogramParams struct {
	ID         int32          `json:"id"`
	Name       string         `json:"name"`
	NumPockets int32          `json:"num_pockets"`
	Notes      sql.NullString `json:"notes"`
}

func (q *Queries) UpdatePlanogram(ctx context.Context, arg UpdatePlanogramParams) (Planogram, error) {
	row := q.queryRow(ctx, q.updatePlanogramStmt, updatePlanogram,
		arg.ID,
		arg.Name,
		arg.NumPockets,
		arg.Notes,
	)
	var i Planogram
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NumPockets,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePlanogramPocket = `-- name: UpdatePlanogramPocket :one
UPDATE planogram_pockets
SET category = $2,
    product_id = $3
WHERE id = $1
RETURNING id, planogram_id, pocket_number, category, product_id
`

type UpdatePlanogramPocketParams struct {
	ID        int32         `json:"id"`
	Category  string        `json:"category"`
	ProductID sql.NullInt32 `json:"product_id"`
}

func (q *Queries) UpdatePlanogramPocket(ctx context.Context, arg UpdatePlanogramPocketParams) (PlanogramPocket, error) {
	row := q.queryRow(ctx, q.updatePlanogramPocketStmt, updatePlanogramPocket, arg.ID, arg.Category, arg.ProductID)
	var i PlanogramPocket
	err := row.Scan(
		&i.ID,
		&i.PlanogramID,
		&i.PocketNumber,
		&i.Category,
		&i.ProductID,
	)
	return i, err
}
