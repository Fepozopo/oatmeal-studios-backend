// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: inventory_transactions.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const getAllCurrentInventory = `-- name: GetAllCurrentInventory :many
SELECT
  product_id,
  COALESCE(SUM(change), 0) AS current_inventory
FROM inventory_transactions
GROUP BY product_id
`

type GetAllCurrentInventoryRow struct {
	ProductID        uuid.UUID   `json:"product_id"`
	CurrentInventory interface{} `json:"current_inventory"`
}

func (q *Queries) GetAllCurrentInventory(ctx context.Context) ([]GetAllCurrentInventoryRow, error) {
	rows, err := q.query(ctx, q.getAllCurrentInventoryStmt, getAllCurrentInventory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCurrentInventoryRow
	for rows.Next() {
		var i GetAllCurrentInventoryRow
		if err := rows.Scan(&i.ProductID, &i.CurrentInventory); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentInventory = `-- name: GetCurrentInventory :one
SELECT COALESCE(SUM(change), 0) AS current_inventory
FROM inventory_transactions
WHERE product_id = $1
`

func (q *Queries) GetCurrentInventory(ctx context.Context, productID uuid.UUID) (interface{}, error) {
	row := q.queryRow(ctx, q.getCurrentInventoryStmt, getCurrentInventory, productID)
	var current_inventory interface{}
	err := row.Scan(&current_inventory)
	return current_inventory, err
}

const getInventoryChangesByDay = `-- name: GetInventoryChangesByDay :many
SELECT
  DATE(created_at) AS day,
  SUM(change) AS inventory_change
FROM inventory_transactions
WHERE product_id = $1
GROUP BY day
ORDER BY day
`

type GetInventoryChangesByDayRow struct {
	Day             time.Time `json:"day"`
	InventoryChange int64     `json:"inventory_change"`
}

func (q *Queries) GetInventoryChangesByDay(ctx context.Context, productID uuid.UUID) ([]GetInventoryChangesByDayRow, error) {
	rows, err := q.query(ctx, q.getInventoryChangesByDayStmt, getInventoryChangesByDay, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInventoryChangesByDayRow
	for rows.Next() {
		var i GetInventoryChangesByDayRow
		if err := rows.Scan(&i.Day, &i.InventoryChange); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertInventoryTransaction = `-- name: InsertInventoryTransaction :one
INSERT INTO inventory_transactions (product_id, change, reason, notes)
VALUES ($1, $2, $3, $4)
RETURNING id, product_id, change, reason, created_at, notes
`

type InsertInventoryTransactionParams struct {
	ProductID uuid.UUID      `json:"product_id"`
	Change    int32          `json:"change"`
	Reason    string         `json:"reason"`
	Notes     sql.NullString `json:"notes"`
}

func (q *Queries) InsertInventoryTransaction(ctx context.Context, arg InsertInventoryTransactionParams) (InventoryTransaction, error) {
	row := q.queryRow(ctx, q.insertInventoryTransactionStmt, insertInventoryTransaction,
		arg.ProductID,
		arg.Change,
		arg.Reason,
		arg.Notes,
	)
	var i InventoryTransaction
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Change,
		&i.Reason,
		&i.CreatedAt,
		&i.Notes,
	)
	return i, err
}

const listInventoryTransactions = `-- name: ListInventoryTransactions :many
SELECT id, product_id, change, reason, created_at, notes
FROM inventory_transactions
WHERE product_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListInventoryTransactions(ctx context.Context, productID uuid.UUID) ([]InventoryTransaction, error) {
	rows, err := q.query(ctx, q.listInventoryTransactionsStmt, listInventoryTransactions, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryTransaction
	for rows.Next() {
		var i InventoryTransaction
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Change,
			&i.Reason,
			&i.CreatedAt,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
